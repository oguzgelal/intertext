% !TEX root = ../thesis.tex

\chapter{Related Work} \label{relatedWork}

This section explores and discusses the state-of-the-art research, tools, and technologies in the field of user interface development. First, we focus on existing UIDLs and how they compare to Intertext. We categorise them to demonstrate the relevancy as coherently as possible and investigate the ones that fall into the same category as Intertext on a case-by-case basis. Then, we look into libraries and frameworks that aim to achieve a similar goal as Intertext. We will explain how Intertext is extending the existing solutions to do what it does. Moreover, we will explore commercially available tools and services and discuss why they are relevant to Intertext and what is to be learned from their efforts and success.

\section{UIDLs} \label{relatedUIDLs}

A UIDL can be defined as having two separate parts: a syntax that describes the user interface characteristics, and semantics that defines what these characteristics mean. They share the common goal of describing a UI without targeting any particular programming language or platform; nevertheless, the end-goal of UIDLs often varies \cite{XMLCompliantUIDLs}. UIDLs typically use XML or a similar markup language/notation that later gets transpiled into a programming language or is processed by a software to be automatically or semi-automatically translated into a UI, a visualisation, or any byproduct depending on the goal of the project. A UIDL can be thought of as a tool designed to achieve a particular goal or a common goal in a particular way. 

Souchon et al., \cite{XMLCompliantUIDLs}, and later Guerrero-Garcia et al. \cite{UIDLTheoreticalSurvey} argued \textit{"there is a plethora of UIDLs that are widely used, with different goals and different strengths"}. There are many ways of classifying and categorising existing UIDLs, as can be seen in \cite{XMLCompliantUIDLs} and \cite{UIDLTheoreticalSurvey}. However, in this section, to stay relevant to the comparison to Intertext, we group UIDLs under two main categories: compiled and interpreted UIDLs. Almost all existing IUIDLs falls under the first category, allowing us to focus on the general picture instead of on a case-by-case basis.

\subsubsection{Compiled UIDLs}

Compiled refers to cases where UI descriptions are created at design time and are used to generate code or the final UI for different target platforms and environments. They often rely on a transformational approach; they utilise a reference framework for classifying UI elements with multiple levels of abstraction, and reify them into more concrete levels based on the target platform and context of use. OpenUIDL \cite{openuidl}, UIML \cite{UIML}, XIML \cite{XIML}, TeresaXML \cite{TeresaXML}, MariaXML \cite{MariaXML} and UsiXML \cite{UsiXML} are several examples of UIDLs that uses this model. 

\subsubsection{Interpreted UIDLs}

Interpreted UIDLs are closer to Intertext UIDL as they are interpreted during runtime rather than being compiled on the build time. Almost all UIDLs falls under the compiled category, nevertheless one project that was the similar to Intertext in the sense that it is a UIDL designed to be interpreted at the runtime is \textbf{Seescoa XML} \cite{seescoa}. 

Seescoa (Software Engineering for Embedded Systems using a Component Oriented Approach) is a framework for user interface migrations during runtime. It proposes an XML-based syntax for interfaces to be described in, which is an abstraction of a user interface that consists of Abstract Interaction Objects (AIO). The main goal is for UIs to be serialised into AIOs, then be moved on to another device where it would be deserialised into platform specific concrete interaction objects (CIOs) then to a user interface on. For serialisation/deserialisation on every platform, an XSLT needs to be defined, which maps the AIOs and CIOs for that particular platform, so the migration process is designed to be semi-automatic.

\subsubsection{Comparison}

We explored UIDLs under two main categories. Some of them show similarities with Intertext in some respect, whereas others are radically different. The differences between many of them include but are not limited to:

\begin{enumerate}
  \item Intertext focuses on graphical user interfaces (GUIs), while many other UIDLs covers different kinds of UIs.
  
  \item Intertext has a single level of abstraction, unlike many of the other UIDLs with multiple levels of abstraction, mostly due to their wider focus.
  
  \item IUIDL is interpreted. It relies on reifying the single level of its abstraction into the final UI on-the-fly, whereas the final UI for the UIDLs in the first category is generated during compile time. And for Seescoa, it is a semi-automatic process that relies on XSLT definition to be created for every platform to be supported.
  
  \item The UI descriptions are created manually during design time for many UIDLs (or, in some cases, generated by several different means). However, for Intertext, it is meant to be generated and served on-the-fly from an endpoint based on the application logic and UI state.
  
  \item Unlike Intertext, most UIDLs with a model-based approach incorporates heavy user interactions.
\end{enumerate}

Nonetheless, if we were to take a step back to look at the big picture, Intertext has a fundamental difference that separates itself from the others; it is the purpose. The value added by the UIDLs is to improve the development process of user interfaces, reduce the cost and effort of creating UI descriptions that can target multiple platforms and environments with minimal to none additional effort. The byproduct of these UIDLs is a functioning user interface on each target platform. While we aim to take advantage of the nature of UIDLs to enable some of these advancements, we also have an equal focus on the user and improving the user experience. Unlike other UIDLs that double down on creating the best UI development experience and producing the most comprehensive outcome possible, we intentionally introduce calculated limitations such as style agnosticism and disallowing third-party code execution to benefit users equally, if not more. Although we provide more details on Intertext clients and IUIDL in \nameref{solution} and \nameref{implementation} sections, we can summarise our efforts that distinguish Intertext from other UIDLs as below:

\begin{enumerate}
  \item Intertext is style-agnostic so that users can customise the look-and-feel of the UIs to their liking.
  
  \item The final UI rendered for each platform and environment cannot be altered to ensure the quality and accessibility of the UI elements.
  
  \item The output of IUIDL is solely presentational with support for minimal user interactions. Application logic is expected to be implemented on a generic backend, where the IUIDL is meant to be served from.

  \item Intertext, in general, is a platform that comes with Intertext UIDL (IUIDL) and software clients that can interpret and render it. It has no intention of generating a UI that can run independently.
\end{enumerate}

\section{Frameworks and Libraries} \label{relatedTools}

The issue of cross-platform development has long been an active research topic, especially after the rise of popularity in mobile devices, tablets and wearable technologies. There has been number of solutions that aims to solve this issue, and the traditional approach is hybrid application development. The idea of hybrid application development is to have a single codebase that can either run on multiple devices, or compile into an application that can natively run on multiple devices. Around this concept there has been many tools and libraries, and it has been gaining traction in the recent days.

One of the most notable example to these libraries is React Native. React Native is a mobile application framework that works under React, and generates UI elements native to the platform that the code is being compiled against. Once an application is built with React Native, it can be compiled as a native iOS or an Android application \cite{ReactNative}. Another framework recently gaining traction is Flutter by Google, it takes the hybrid application development to the next level by supporting web, mobile environments and popular desktop environments \cite{Flutter}.


\section{Tools and Services} \label{relatedTools}

Over the past couple of years, there has been a significant shift towards no-code tools and services that aims to allow non-technical users with no development or engineering background to build products or automate tasks that would have normally required assistance from engineers with technical skills. This movement lead to the rise of a new category of products; products allows users to create front-end applications without front-end development. There are variety of different products that falls into this category, and there are different approaches taken by these products to achieve similar goals.

\subsection{Website Builders}

First of all, there are services such as Wix \cite{Wix} or SquareSpace \cite{SquareSpace} that allows you to design and publish a website via a drag and drop interface. They offer services on the web environment. While they mostly focus on the design aspects of website development, they offer pre-made customisable backends for specific use cases such as blogs and e-commerce websites.

\subsection{Content Management Systems}

Then there are Content Management Systems (CMS) like Wordpress \cite{Wordpress}, Drupal \cite{Drupal} and Joomla \cite{Joomla}. These services are not new and has been around for some time. They also offer services only for the web platform. It is also possible to create a front-end application using these services, but in order to go beyond a pre-made theme, they often required to have minimal front-end development knowledge. Moreover, they allow users to create their own data structures and provide the user interface to manipulate data. There are also Headless CMS services such as Contentful \cite{Contentful} and Strapi \cite{Strapi} that allows users to create and manage their data, but does not provide a front-end and allow the data to be consumed through an API from any front-end application.

\subsection{Static Site Generators}

Static site generation is a process of taking an input from the user and generating a static web content ready to be served by a web server. This input is typically Javascript code as many static site generators such as Gatsby \cite{Gatsby} and Next.js \cite{Nextjs} are based on Javascript frameworks and requires programming knowledge, but there are ones such as Jekyll \cite{Jekyll} that uses markdown syntax, and renders within a given theme.

\subsection{Internal Tool Builders}

These services are mostly intended for developers to use. They aim to help developers rapidly produce better and durable tools that are not user-facing and are to be used internally within a company. They provide GUI components, and integration options to number of services as well as direct databases. The intended use for these tools is to pull data from a number of data sources, process it and display it using the provided GUI components. Retool \cite{Retool} is a popular example that only targets the web platform, but there are also some similar tools in this category that also produces native-like experiences.
